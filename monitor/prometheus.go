package monitor

import (
	"bytes"
	"errors"

	"github.com/jumptrading/influx-spout/convert"
)

// Metric represents a single Prometheus metric line, including its
// labels and timestamp.
type Metric struct {
	Name         []byte
	Labels       LabelPairs
	Value        int64
	Milliseconds int64
}

// LabelPairs contains the set of labels for a metric.
type LabelPairs []LabelPair

// LabelPair contains a label name and value.
type LabelPair struct {
	Name  []byte
	Value []byte
}

// ParseMetric parses a single Promethesus metric line.
//
// Note: The implementation currently only supports integer values and
// also doesn't handle escaped characters nor multiple sequential
// whitespace characters. This is OK for now because this only needs
// to support metrics generated by the various influx-spout
// components.
func ParseMetric(s []byte) (*Metric, error) {
	if len(s) < 3 {
		return nil, errors.New("invalid metric")
	}

	out := new(Metric)
	var err error

	i := bytes.IndexAny(s, " {")
	if i == -1 {
		return nil, errors.New("no value")
	}
	out.Name = s[:i]

	if s[i] == '{' {
		i++
		labels, n, err := parseLabels(s[i:])
		if err != nil {
			return nil, err
		}
		out.Labels = labels
		i += n
	}

	i++
	j := bytes.IndexByte(s[i:], ' ')
	if j == -1 {
		j = len(s[i:]) // No timestamp
	}
	out.Value, err = convert.ToInt(s[i : i+j])
	if err != nil {
		return nil, errors.New("invalid value")
	}

	i += j
	if i < len(s) {
		out.Milliseconds, err = convert.ToInt(s[i+1:])
		if err != nil {
			return nil, errors.New("invalid timestamp")
		}
	}

	return out, nil
}

func parseLabels(s []byte) (LabelPairs, int, error) {
	if s[0] == '}' {
		return nil, 1, nil
	}

	i := 0
	out := make(LabelPairs, 0, 1)
	for {
		var label LabelPair

		j := bytes.Index(s[i:], []byte(`="`))
		if j == -1 {
			return nil, i, errors.New("invalid label")
		}
		label.Name = s[i : i+j]
		i = i + j + 2

		j = bytes.IndexByte(s[i:], '"')
		if j == -1 {
			return nil, i, errors.New("missing label closing quote")
		}
		label.Value = s[i : i+j]
		i = i + j + 1

		out = append(out, label)

		switch s[i] {
		case '}':
			return out, i + 1, nil
		case ',':
			i++
		default:
			return nil, i, errors.New("invalid label separator")
		}
	}
}
