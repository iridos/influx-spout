// Copyright 2018 Jump Trading
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package monitor

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/jumptrading/influx-spout/convert"
)

// ParseMetric parses a single Promethesus metric line.
//
// Note: The implementation currently only supports integer values and
// also doesn't handle escaped characters nor multiple sequential
// whitespace characters. This is OK for now because this only needs
// to support metrics generated by the various influx-spout
// components.
func ParseMetric(s []byte) (*Metric, error) {
	if len(s) < 3 {
		return nil, errors.New("invalid metric")
	}

	out := new(Metric)
	var err error

	i := bytes.IndexAny(s, " {")
	if i == -1 {
		return nil, errors.New("no value")
	}
	out.Name = s[:i]

	if s[i] == '{' {
		i++
		labels, n, err := parseLabels(s[i:])
		if err != nil {
			return nil, err
		}
		out.Labels = labels
		i += n
	}

	i++
	j := bytes.IndexByte(s[i:], ' ')
	if j == -1 {
		j = len(s[i:]) // No timestamp
	}
	out.Value, err = convert.ToInt(s[i : i+j])
	if err != nil {
		return nil, errors.New("invalid value")
	}

	i += j
	if i < len(s) {
		out.Milliseconds, err = convert.ToInt(s[i+1:])
		if err != nil {
			return nil, errors.New("invalid timestamp")
		}
	}

	return out, nil
}

func parseLabels(s []byte) (LabelPairs, int, error) {
	if s[0] == '}' {
		return nil, 1, nil
	}

	i := 0
	out := make(LabelPairs, 0, 1)
	for {
		var label LabelPair

		j := bytes.Index(s[i:], []byte(`="`))
		if j == -1 {
			return nil, i, errors.New("invalid label")
		}
		label.Name = s[i : i+j]
		i = i + j + 2

		j = bytes.IndexByte(s[i:], '"')
		if j == -1 {
			return nil, i, errors.New("missing label closing quote")
		}
		label.Value = s[i : i+j]
		i = i + j + 1

		out = append(out, label)

		switch s[i] {
		case '}':
			return out, i + 1, nil
		case ',':
			i++
		default:
			return nil, i, errors.New("invalid label separator")
		}
	}
}

// Metric represents a single Prometheus metric line, including its
// labels and timestamp.
type Metric struct {
	Name         []byte
	Labels       LabelPairs
	Value        int64
	Milliseconds int64
}

// ToBytes renders the metric to wire format.
func (m *Metric) ToBytes() []byte {
	out := bytes.NewBuffer(m.Name)
	if len(m.Labels) > 0 {
		out.Write(m.Labels.ToBytes())
	}
	fmt.Fprintf(out, " %d", m.Value)
	if m.Milliseconds > 0 {
		fmt.Fprintf(out, " %d", m.Milliseconds)
	}
	return out.Bytes()
}

// LabelPairs contains the set of labels for a metric.
type LabelPairs []LabelPair

// ToBytes renders the label name and value to wire format.
func (p LabelPairs) ToBytes() []byte {
	out := new(bytes.Buffer)
	out.WriteByte('{')
	for i, label := range p {
		fmt.Fprintf(out, `%s="%s"`, label.Name, label.Value)
		if i < len(p)-1 {
			out.WriteByte(',')
		}
	}
	out.WriteByte('}')
	return out.Bytes()
}

// LabelPair contains a label name and value.
type LabelPair struct {
	Name  []byte
	Value []byte
}
